#!/usr/bin/env bash

# @describe search github repositories
# @arg term "search term" [string]
# @option -l --limit "number of results to display" [int] @default "10"
# @option -e --email "search by contributor email address (supports * wildcard)" [string]
# @option -a --author "search by commit author name" [string]
# @option -o --org "search in specific organization" [string]
# @option -u --user "search in repositories owned by user" [string]
# @option -s --sort "sort by (stars, forks, updated)" [string] @default "stars"
# @flag   -j --json "output raw JSON instead of formatted results"
# @flag   -q --quiet "suppress colored output"
# @flag   -d --deep "perform deeper analysis on found repos" [flag]
# @flag   -f --fork "include forked repositories" [flag]
# @flag   -c --contributors "enumerate all contributors across repositories (requires --org or --user)"
# @meta require-tools curl,jq,git,trufflehog

eval "$(argc --argc-eval "$0" "$@")"

if [ "$argc_quiet" = 1 ] || [ -z "$TERM" ] || [ "$TERM" = "dumb" ]; then
  bold=""
  reset=""
  blue=""
  green=""
  yellow=""
  cyan=""
  magenta=""
  red=""
else

  bold=$(tput bold)
  reset=$(tput sgr0)
  blue=$(tput setaf 4)
  green=$(tput setaf 2)
  yellow=$(tput setaf 3)
  cyan=$(tput setaf 6)
  magenta=$(tput setaf 5)
  red=$(tput setaf 1)
fi

if [ -z "$argc_term" ] && [ "$argc_contributors" != 1 ]; then
  "$0" -h
  exit 1
fi

if [ -f "$HOME/.config/github/token" ]; then
  GITHUB_TOKEN=$(cat "$HOME/.config/github/token")
  auth_header="Authorization: token $GITHUB_TOKEN"
elif [ -n "$GITHUB_TOKEN" ]; then
  auth_header="Authorization: token $GITHUB_TOKEN"
else
  echo "${yellow}Warning:${reset} No GitHub token found. API rate limits will be restricted." >&2
  echo "Create a token at https://github.com/settings/tokens and save it to ~/.config/github/token" >&2
  auth_header=""
fi

search_query="$argc_term"

if [ -n "$argc_email" ]; then
  search_query="$search_query author-email:$argc_email"
fi

if [ -n "$argc_author" ]; then
  search_query="$search_query author:$argc_author"
fi

if [ -n "$argc_org" ]; then
  search_query="$search_query org:$argc_org"
fi

if [ -n "$argc_user" ]; then
  search_query="$search_query user:$argc_user"
fi

if [ "$argc_fork" != 1 ]; then
  search_query="$search_query fork:false"
fi

encoded_query=$(echo "$search_query" | sed 's/ /%20/g')

[ -z "$argc_limit" ] && argc_limit="10"

[ -z "$argc_sort" ] && argc_sort="stars"
url="https://api.github.com/search/repositories?q=$encoded_query&sort=$argc_sort&per_page=$argc_limit"

if [ "$argc_json" != 1 ]; then
  printf "${bold}Searching GitHub:${reset} ${blue}%s${reset}" "$argc_term"
  [ -n "$argc_email" ] && printf " ${bold}by email:${reset} ${magenta}%s${reset}" "$argc_email"
  [ -n "$argc_author" ] && printf " ${bold}by author:${reset} ${magenta}%s${reset}" "$argc_author"
  [ -n "$argc_org" ] && printf " ${bold}in org:${reset} ${magenta}%s${reset}" "$argc_org"
  [ -n "$argc_user" ] && printf " ${bold}for user:${reset} ${magenta}%s${reset}" "$argc_user"

  limit_display="${argc_limit:-10}"
  sort_display="${argc_sort:-stars}"
  printf " (limit: ${yellow}%s${reset}, sorting by: ${cyan}%s${reset})\n" "$limit_display" "$sort_display"
  printf "%s\n" "----------------------------------------"
fi

analyze_repo() {
  local repo_name="$1"
  local repo_api_name="$2"

  printf "${bold}${cyan}Analyzing ${repo_name}...${reset}\n"

  # get repository details and emails
  printf "${bold}${yellow}Recent Contributors:${reset}\n"
  if [ -n "$auth_header" ]; then
    contributors=$(curl -s -H "$auth_header" "https://api.github.com/repos/${repo_api_name}/contributors?per_page=10")
  else
    contributors=$(curl -s "https://api.github.com/repos/${repo_api_name}/contributors?per_page=10")
  fi

  echo "$contributors" | jq -r '.[] | "\(.contributions) - \(.login)"' |
    awk '{printf "  %s - %s\n", $1, substr($0, length($1)+4)}'

  # commit patterns - this is a bit more complex but bassically
  # we want to find the most common commit patterns
  # this includes the date and hour of the commit
  # we'll use the commit author date to find patterns like 
  # "most commits on Mondays at 10:00"
  # this is useful for finding active times of the repository
  # and can help identify when contributors are most active
  # we'll also check for email addresses in the commit data
  # and print a sample of the emails found
  printf "\n${bold}${yellow}Commit Patterns:${reset}\n"
  if [ -n "$auth_header" ]; then
    commits=$(curl -s -H "$auth_header" "https://api.github.com/repos/${repo_api_name}/commits?per_page=100")
  else
    commits=$(curl -s "https://api.github.com/repos/${repo_api_name}/commits?per_page=100")
  fi

  echo "$commits" | jq -r '.[].commit.author.date' |
    awk -F'T' '{print $1, substr($2,1,2)}' | sort | uniq -c |
    sort -k2,2 -k3,3 | tail -10 |
    awk '{printf "  %s commits on %s at %s:00 hour\n", $1, $2, $3}'

  # check for email addresses
  email_count=$(echo "$commits" | jq '[.[] | select(.commit.author.email != null and .commit.author.email != "")] | length')
  printf "\n${bold}${yellow}Email Check:${reset} Found ${cyan}%s${reset} commits with email addresses\n" "$email_count"

  if [ "$email_count" -gt 0 ]; then
    printf "${bold}${yellow}Sample Emails:${reset}\n"
    echo "$commits" | jq -r '.[] | select(.commit.author.email != null and .commit.author.email != "") | "\(.commit.author.name) <\(.commit.author.email)>"' |
      sort -u | head -3 | sed 's/^/  /'
  else
    printf "${yellow}No emails found in commit data. This is likely due to GitHub API privacy restrictions.${reset}\n"
  fi

  # commit authors and emails
  printf "\n${bold}${yellow}Commit Authors:${reset}\n"
  echo "$commits" | jq -r '.[] | "\(.commit.author.name) <\(.commit.author.email)>"' | sort -u | head -5 |
    sed 's/^/  /'

  # get repository contents
  printf "\n${bold}${yellow}Interesting Files:${reset}\n"
  if [ -n "$auth_header" ]; then
    contents=$(curl -s -H "$auth_header" "https://api.github.com/repos/${repo_api_name}/git/trees/HEAD?recursive=1")
  else
    contents=$(curl -s "https://api.github.com/repos/${repo_api_name}/git/trees/HEAD?recursive=1")
  fi

  echo "$contents" | jq -r '.tree[] | select(.type=="blob") | .path' |
    grep -E '\.conf$|\.env|\.key$|config\.|\.yml$|\.yaml$|\.json$|\.xml$|\.pem$|\.crt$|\.cer$' |
    grep -v "node_modules\|vendor" | head -10 |
    sed 's/^/  /'
}

enumerate_contributors() {
  local target="$1"
  local target_type="$2" # 'user' or 'org'
  local page=1
  local repos=()
  local all_repos_json=""

  printf "${bold}${cyan}Enumerating repositories for ${target_type} '${target}'...${reset}\n"

  # fetch all repositories for the user/org
  while true; do
    local url="https://api.github.com/${target_type}s/${target}/repos?per_page=100&page=${page}"
    if [ "$argc_fork" != 1 ]; then
      if [ "$target_type" = "org" ]; then
        url="${url}&type=sources" # use 'sources' for orgs to exclude forks reliably
      else                        # user
        :                         # skip user
      fi
    fi

    local repos_json
    if [ -n "$auth_header" ]; then repos_json=$(curl -s -L -H "$auth_header" "$url"); else repos_json=$(curl -s -L "$url"); fi # Added -L for redirects

    if ! echo "$repos_json" | jq -e . >/dev/null 2>&1; then
      printf "${red}Error:${reset} Invalid JSON received from GitHub API for repos page ${page}. URL: ${url}\n" >&2
      printf "Response was: %s\n" "$repos_json" >&2
      return 1
    fi
    if echo "$repos_json" | jq -e '.message' >/dev/null 2>&1; then
      printf "${red}Error:${reset} GitHub API returned: %s\n" "$(echo "$repos_json" | jq -r '.message')"
      if [ ${#repos[@]} -eq 0 ]; then return 1; else break; fi
    fi
    if [ "$(echo "$repos_json" | jq '. | length')" -eq 0 ]; then break; fi

    while read -r repo fork_status; do
      if [ "$argc_fork" != 1 ] && [ "$fork_status" = "true" ]; then
        printf "  ${yellow}Skipping fork:${reset} ${blue}%s${reset}\n" "$repo"
        continue
      fi
      repos+=("$repo")
    done < <(echo "$repos_json" | jq -r '.[] | "\(.full_name) \(.fork)"')

    ((page++))
    # sleep 0.2 # be nice to the api
  done

  total_repos=${#repos[@]}
  fork_status=""
  if [ "$argc_fork" = 1 ]; then fork_status=" (including forks)"; else fork_status=" (excluding forks)"; fi
  printf "${bold}Found ${yellow}%s${reset} repositories${reset}${cyan}%s${reset}\n\n" "$total_repos" "$fork_status"

  if [ "$total_repos" -eq 0 ]; then
    printf "${yellow}No repositories found matching criteria.${reset}\n"
    return 0
  fi

  temp_file=$(mktemp)
  trap 'rm -f "$temp_file"' EXIT TERM INT

  total_direct_commits_all_repos=0
  total_merge_commits_all_repos=0

  repo_count=0
  for repo in "${repos[@]}"; do
    ((repo_count++))
    printf "${bold}Processing repo ${yellow}%d/%d${reset}: ${green}%s${reset}...${reset}\n" "$repo_count" "$total_repos" "$repo"

    local commits_page=1
    local direct_commit_count_repo=0
    local merge_commit_count_repo=0

    while true; do
      local commits_url="https://api.github.com/repos/${repo}/commits?per_page=100&page=${commits_page}"
      local commits_json
      if [ -n "$auth_header" ]; then commits_json=$(curl -s -L -H "$auth_header" "$commits_url"); else commits_json=$(curl -s -L "$commits_url"); fi # Added -L

      if ! echo "$commits_json" | jq -e . >/dev/null 2>&1; then
        printf "  ${red}Error:${reset} Invalid JSON received from GitHub API for commits page ${commits_page}. URL: ${commits_url}\n" >&2
        printf "  Response was: %s\n" "$commits_json" >&2

        # actually unsure whether to break or continue lol
        break
      fi
      if echo "$commits_json" | jq -e '.message' >/dev/null 2>&1; then
        error_msg=$(echo "$commits_json" | jq -r '.message')
        if [[ "$error_msg" == "Git Repository is empty." ]]; then
          printf "  ${yellow}Skipping empty repository.${reset}\n"
        elif [[ "$error_msg" == "Not Found" ]]; then
          printf "  ${red}Error:${reset} Repository not found or insufficient permissions: ${red}%s${reset}\n" "$repo"
        elif [[ "$error_msg" == *"API rate limit exceeded"* ]]; then
          printf "  ${red}Error:${reset} API rate limit exceeded. Try again later or use a token.\n"
          # getting rate limit sneed :(
        else
          printf "  ${yellow}Warning:${reset} Could not fetch commits: ${yellow}%s${reset}\n" "$error_msg"
        fi
        break
      fi
      if [ "$(echo "$commits_json" | jq '. | length')" -eq 0 ]; then break; fi

      direct_count=$(echo "$commits_json" | jq '[.[] | select(.parents | length <= 1)] | length')
      merge_count=$(echo "$commits_json" | jq '[.[] | select(.parents | length > 1)] | length')
      direct_commit_count_repo=$((direct_commit_count_repo + direct_count))
      merge_commit_count_repo=$((merge_commit_count_repo + merge_count))

      echo "$commits_json" | jq -c -r --arg repo "$repo" ' 
          .[] |
          select(.parents | length <= 1) | 
          select(.commit.author.email != null and .commit.author.email != "" and (.commit.author.email | contains("@") ) ) | 
          select(.commit.author.date != null) | # Ensure date exists
          {
              repo: $repo,
              name: .commit.author.name,
              email: .commit.author.email,
              date: .commit.author.date,
              login: (if .author and .author.login then .author.login else null end) # Get login if available
          }
          ' >>"$temp_file"

      ((commits_page++))
      sleep 0.1
    done

    total_repo_commits=$((direct_commit_count_repo + merge_commit_count_repo))
    total_direct_commits_all_repos=$((total_direct_commits_all_repos + direct_commit_count_repo))
    total_merge_commits_all_repos=$((total_merge_commits_all_repos + merge_commit_count_repo))
    printf "  ${cyan}Processed${reset} ${yellow}%s${reset} total commits (${cyan}%s${reset} direct, ${magenta}%s${reset} merge)\n" "$total_repo_commits" "$direct_commit_count_repo" "$merge_commit_count_repo"
    sleep 0.1 # Sleep between repos
  done

  printf "\n${bold}${cyan}Direct Commit Author Summary:${reset}\n"
  printf "${bold}%-40s %-30s %-50s${reset}\n" "Email" "Name" "Repositories (Direct Commits)"
  printf "%-40s %-30s %-50s\n" "$(printf -- '%.0s-' {1..40})" "$(printf -- '%.0s-' {1..30})" "$(printf -- '%.0s-' {1..50})"

  if [ ! -s "$temp_file" ]; then
    printf "${yellow}No direct commit authors with email addresses found across scanned repositories.${reset}\n"
  else
    jq -s ' 
      group_by(.email) |
      map({
          email: .[0].email,
          name: .[0].name,
          repos: map(.repo) | unique | sort, 
          logins: map(.login) | unique | map(select(. != null)) | sort,
          direct_commit_count: length, # Count of direct commits across all repos
          last_direct_commit_date: map(.date) | sort | reverse[0] # Date of last direct commit
      }) | sort_by(.name) 
      ' "$temp_file" | jq -r '.[] |
          .email as $email |
          .name as $name |
          # Join repos into a comma-separated string for display
          (.repos | join(", ")) as $repos_str |
          $email + "|" + $name + "|" + $repos_str
      ' |
      while IFS="|" read -r email name repos_str; do

        email_trunc=$(echo "$email" | awk '{ if(length($0) > 38) { print substr($0, 1, 37) "…" } else { print $0 } }')
        name_trunc=$(echo "$name" | awk '{ if(length($0) > 28) { print substr($0, 1, 27) "…" } else { print $0 } }')
        repos_trunc=$(echo "$repos_str" | awk '{ if(length($0) > 48) { print substr($0, 1, 45) "..." } else { print $0 } }')

        printf "${magenta}%-40s${reset} ${green}%-30s${reset} ${blue}%-50s${reset}\n" \
          "$email_trunc" "$name_trunc" "$repos_trunc"
      done

    printf "\n${bold}${yellow}Recent Direct Commit Timestamps (Most Recent 50):${reset}\n"
    jq -r '.date + "|" + .name + "|" + .email + "|" + .repo' "$temp_file" |
      sort -r |
      head -n 50 |
      while IFS="|" read -r timestamp name email repo; do
        date_part=$(echo "$timestamp" | cut -dT -f1)
        time_part=$(echo "$timestamp" | cut -dT -f2 | cut -d. -f1)
        tz_part=$(echo "$timestamp" | grep -o '[+-][0-9]\{2\}:[0-9]\{2\}$' || echo "Z")

        repo_short=$(echo "$repo" | sed 's|.*/||')

        printf "  ${cyan}%s${reset} ${magenta}%s${reset} ${yellow}%s${reset} by ${green}%s${reset} <${blue}%s${reset}> in ${yellow}%s${reset}\n" \
          "$date_part" "$time_part" "$tz_part" \
          "$(echo "$name" | cut -c 1-20)" \
          "$(echo "$email" | cut -c 1-25)" \
          "$repo_short"
      done

    output_file="direct-commit-authors-${target_type}-${target}-$(date +%Y%m%d-%H%M%S).json"
    jq -s '
      group_by(.email) |
      map({
          email: .[0].email,
          name: .[0].name,
          repos: map(.repo) | unique | sort,
          logins: map(.login) | unique | map(select(. != null)) | sort,
          direct_commit_count: length,
          last_direct_commit_date: map(.date) | sort | reverse[0]
      }) | sort_by(-.direct_commit_count) 
      ' "$temp_file" >"$output_file"

    printf "\n${bold}${yellow}Top Direct Commit Authors (by commit count):${reset}\n"
    jq -r '.[0:10] | .[] | "\(.direct_commit_count) direct commits - \(.name) <\(.email)>"' "$output_file" 2>/dev/null |
      sed 's/^/  /'

    printf "\n${bold}${yellow}All Direct Commit Authors (Name and Email):${reset}\n"
    jq -r 'sort_by(.name) | .[] | "\(.name) <\(.email)>"' "$output_file" | sort -u |
      sed 's/^/  /'

    printf "\n${bold}${yellow}Recent Direct Commit Authors:${reset}\n"
    jq -r 'sort_by(.last_direct_commit_date) | reverse | .[0:10] | .[] | "\(.name) <\(.email)> (last direct commit: \(.last_direct_commit_date | split("T")[0]))"' "$output_file" 2>/dev/null |
      sed 's/^/  /'

    printf "\n${bold}${yellow}Data saved to:${reset} ${cyan}%s${reset}\n" "$output_file"

  fi

  printf "\n${bold}${yellow}Summary:${reset}\n"
  printf "%s Total repositories scanned: ${cyan}%s${reset}\n" "-" "$total_repos"
  printf "%s Total direct commits found: ${cyan}%s${reset}\n" "-" "$total_direct_commits_all_repos"
  printf "%s Total merge commits found: ${cyan}%s${reset}\n" "-" "$total_merge_commits_all_repos"

  if [ -s "$temp_file" ]; then
    unique_authors=$(jq -s 'group_by(.email) | length' "$temp_file" 2>/dev/null || echo "N/A")
    printf "%s Unique direct commit authors found (with email): ${cyan}%s${reset}\n" "-" "$unique_authors"

    unique_emails=$(jq -s '[.[] | .email] | unique | length' "$temp_file" 2>/dev/null || echo "N/A")
    printf "%s Unique email addresses found in direct commits: ${cyan}%s${reset}\n" "-" "$unique_emails"

    if [ "$unique_emails" != "0" ] && [ "$unique_emails" != "N/A" ]; then
      email_domains=$(jq -r '.email | select(type=="string" and contains("@")) | split("@")[1]' "$temp_file" 2>/dev/null | sort -u)
      if [ -n "$email_domains" ]; then
        printf "%s Email domains: ${cyan}%s${reset}\n" "-" "$(echo "$email_domains" | tr '\n' ', ' | sed 's/,$//' | sed 's/,/, /g')"
      else
        printf "%s ${yellow}No valid email domains found in direct commits${reset}\n" "-"
      fi
    else
      printf "%s ${yellow}No email domains found${reset}\n" "-"
      printf "  ${yellow}Note: Some commits might lack email info or privacy settings hide it.${reset}\n"
    fi
  else
    printf "%s Unique direct commit authors found (with email): ${cyan}0${reset}\n" "-"
    printf "%s Unique email addresses found in direct commits: ${cyan}0${reset}\n" "-"
    printf "%s ${yellow}No email domains found${reset}\n" "-"
  fi

  rm -f "$temp_file"
  trap - EXIT TERM INT

}

if [ "$argc_contributors" = "true" ] || [ "$argc_contributors" = "1" ]; then
  printf "${bold}${cyan}Starting contributor enumeration...${reset}\n"

  if [ -n "$argc_org" ]; then
    enumerate_contributors "$argc_org" "org"
    exit $?
  elif [ -n "$argc_user" ]; then
    enumerate_contributors "$argc_user" "user"
    exit $?
  else
    printf "${red}Error:${reset} --contributors flag requires either --org or --user to be specified\n"
    printf "\n${bold}Usage examples:${reset}\n"
    printf "  ${cyan}$(basename "$0") --contributors --org spearbit${reset}    # Enumerate contributors in the 'spearbit' organization\n"
    printf "  ${cyan}$(basename "$0") --contributors --user vbuterin${reset}   # Enumerate contributors in repositories owned by 'vbuterin'\n"
    printf "\nFor full help, run: ${cyan}$(basename "$0") --help${reset}\n"
    exit 1
  fi
fi

if [ -n "$auth_header" ]; then
  response=$(curl -s -H "$auth_header" "$url")
else
  response=$(curl -s "$url")
fi

if echo "$response" | jq -e '.message' >/dev/null 2>&1; then
  error_msg=$(echo "$response" | jq -r '.message')
  printf "${red}Error:${reset} GitHub API returned: ${red}%s${reset}\n" "$error_msg"
  exit 1
fi

if [ "$argc_json" = 1 ]; then
  echo "$response" | jq
else
  total_count=$(echo "$response" | jq -r '.total_count')
  printf "${bold}Found ${yellow}%s${reset} matching repositories${reset}\n\n" "$total_count"

  echo "$response" | jq -r '.items[] | "\(.full_name)|\(.stargazers_count)|\(.forks_count)|\(.description)|\(.language)|\(.html_url)|\(.clone_url)|\(.updated_at)"' |
    while IFS="|" read -r repo stars forks desc lang url clone_url updated_at; do
      formatted_date=$(date -d "$updated_at" "+%Y-%m-%d %H:%M" 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$updated_at" "+%Y-%m-%d %H:%M" 2>/dev/null)

      printf "${bold}* ${green}%s${reset} (${yellow}%s*${reset} | ${cyan}%s^${reset})" "$repo" "$stars" "$forks"
      [ -n "$lang" ] && printf " ${magenta}[%s]${reset}" "$lang"
      printf " ${yellow}Updated: %s${reset}\n" "$formatted_date"
      [ -n "$desc" ] && printf "  ${cyan}%s${reset}\n" "$desc"
      printf "  ${blue}%s${reset}\n" "$url"

      if [ "$argc_deep" = 1 ]; then
        analyze_repo "$repo" "$repo"
      fi

      printf "\n"
    done
fi

if [ -n "$auth_header" ]; then
  rate_limit=$(curl -s -H "$auth_header" https://api.github.com/rate_limit)
  remaining=$(echo "$rate_limit" | jq -r '.rate.remaining')
  reset_time=$(echo "$rate_limit" | jq -r '.rate.reset')
  reset_date=$(date -d "@$reset_time" "+%H:%M:%S" 2>/dev/null || date -r "$reset_time" "+%H:%M:%S" 2>/dev/null)

  printf "${bold}${yellow}API Rate Limit:${reset} ${remaining} requests remaining, resets at ${reset_date}\n"
fi
