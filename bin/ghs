#!/usr/bin/env bash

# @describe search github repositories
# @arg term "search term" [string]
# @option -l --limit "number of results to display" [int] @default "10"
# @option -e --email "search by contributor email address (supports * wildcard)" [string]
# @option -a --author "search by commit author name" [string]
# @option -o --org "search in specific organization" [string]
# @option -u --user "search in repositories owned by user" [string]
# @option -s --sort "sort by (stars, forks, updated)" [string] @default "stars"
# @flag   -j --json "output raw JSON instead of formatted results"
# @flag   -q --quiet "suppress colored output"
# @flag   -d --deep "perform deeper analysis on found repos" [flag]
# @flag   -f --fork "include forked repositories" [flag]
# @flag   -c --contributors "enumerate all contributors across repositories (requires --org or --user)"
# @meta require-tools curl,jq,git,trufflehog

# ARGC-BUILD {
# This block was generated by argc (https://github.com/sigoden/argc).
# Modifying it manually is not recommended

_argc_run() {
    if [[ "${1:-}" == "___internal___" ]]; then
        _argc_die "error: unsupported ___internal___ command"
    fi
    if [[ "${OS:-}" == "Windows_NT" ]] && [[ -n "${MSYSTEM:-}" ]]; then
        set -o igncr
    fi
    argc__args=("$(basename "$0" .sh)" "$@")
    argc__positionals=()
    _argc_index=1
    _argc_len="${#argc__args[@]}"
    _argc_tools=()
    _argc_parse
    _argc_require_tools "${_argc_tools[@]}"
    if [ -n "${argc__fn:-}" ]; then
        $argc__fn "${argc__positionals[@]}"
    fi
}

_argc_usage() {
    cat <<-'EOF'
search github repositories

USAGE: ghs [OPTIONS] [TERM]

ARGS:
  [TERM]  "search term" [string]

OPTIONS:
  -l, --limit <LIMIT>    "number of results to display" [int] @default "10"
  -e, --email <EMAIL>    "search by contributor email address (supports * wildcard)" [string]
  -a, --author <AUTHOR>  "search by commit author name" [string]
  -o, --org <ORG>        "search in specific organization" [string]
  -u, --user <USER>      "search in repositories owned by user" [string]
  -s, --sort <SORT>      "sort by (stars, forks, updated)" [string] @default "stars"
  -j, --json             "output raw JSON instead of formatted results"
  -q, --quiet            "suppress colored output"
  -d, --deep             "perform deeper analysis on found repos" [flag]
  -f, --fork             "include forked repositories" [flag]
  -c, --contributors     "enumerate all contributors across repositories (requires --org or --user)"
  -h, --help             Print help
  -V, --version          Print version
EOF
    exit
}

_argc_version() {
    echo ghs 0.0.0
    exit
}

_argc_parse() {
    local _argc_key _argc_action
    local _argc_subcmds=""
    while [[ $_argc_index -lt $_argc_len ]]; do
        _argc_item="${argc__args[_argc_index]}"
        _argc_key="${_argc_item%%=*}"
        case "$_argc_key" in
        --help | -help | -h)
            _argc_usage
            ;;
        --version | -version | -V)
            _argc_version
            ;;
        --)
            _argc_dash="${#argc__positionals[@]}"
            argc__positionals+=("${argc__args[@]:$((_argc_index + 1))}")
            _argc_index=$_argc_len
            break
            ;;
        --limit | -l)
            _argc_take_args "--limit <LIMIT>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_limit:-}" ]]; then
                argc_limit="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--limit\` cannot be used multiple times"
            fi
            ;;
        --email | -e)
            _argc_take_args "--email <EMAIL>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_email:-}" ]]; then
                argc_email="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--email\` cannot be used multiple times"
            fi
            ;;
        --author | -a)
            _argc_take_args "--author <AUTHOR>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_author:-}" ]]; then
                argc_author="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--author\` cannot be used multiple times"
            fi
            ;;
        --org | -o)
            _argc_take_args "--org <ORG>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_org:-}" ]]; then
                argc_org="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--org\` cannot be used multiple times"
            fi
            ;;
        --user | -u)
            _argc_take_args "--user <USER>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_user:-}" ]]; then
                argc_user="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--user\` cannot be used multiple times"
            fi
            ;;
        --sort | -s)
            _argc_take_args "--sort <SORT>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_sort:-}" ]]; then
                argc_sort="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--sort\` cannot be used multiple times"
            fi
            ;;
        --json | -j)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--json\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_json:-}" ]]; then
                _argc_die "error: the argument \`--json\` cannot be used multiple times"
            else
                argc_json=1
            fi
            ;;
        --quiet | -q)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--quiet\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_quiet:-}" ]]; then
                _argc_die "error: the argument \`--quiet\` cannot be used multiple times"
            else
                argc_quiet=1
            fi
            ;;
        --deep | -d)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--deep\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_deep:-}" ]]; then
                _argc_die "error: the argument \`--deep\` cannot be used multiple times"
            else
                argc_deep=1
            fi
            ;;
        --fork | -f)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--fork\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_fork:-}" ]]; then
                _argc_die "error: the argument \`--fork\` cannot be used multiple times"
            else
                argc_fork=1
            fi
            ;;
        --contributors | -c)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--contributors\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_contributors:-}" ]]; then
                _argc_die "error: the argument \`--contributors\` cannot be used multiple times"
            else
                argc_contributors=1
            fi
            ;;
        *)
            if _argc_maybe_flag_option "-" "$_argc_item"; then
                _argc_die "error: unexpected argument \`$_argc_key\` found"
            fi
            argc__positionals+=("$_argc_item")
            _argc_index=$((_argc_index + 1))
            ;;
        esac
    done
    _argc_tools=(curl jq git trufflehog)
    if [[ -n "${_argc_action:-}" ]]; then
        $_argc_action
    else
        if [[ "${argc__positionals[0]:-}" == "help" ]] && [[ "${#argc__positionals[@]}" -eq 1 ]]; then
            _argc_usage
        fi
        _argc_match_positionals 0
        local values_index values_size
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[0]:-}"
        if [[ -n "$values_index" ]]; then
            argc_term="${argc__positionals[values_index]}"
        fi
    fi
}

_argc_take_args() {
    _argc_take_args_values=()
    _argc_take_args_len=0
    local param="$1" min="$2" max="$3" signs="$4" delimiter="$5"
    if [[ "$min" -eq 0 ]] && [[ "$max" -eq 0 ]]; then
        return
    fi
    local _argc_take_index=$((_argc_index + 1)) _argc_take_value
    if [[ "$_argc_item" == *=* ]]; then
        _argc_take_args_values=("${_argc_item##*=}")
    else
        while [[ $_argc_take_index -lt $_argc_len ]]; do
            _argc_take_value="${argc__args[_argc_take_index]}"
            if _argc_maybe_flag_option "$signs" "$_argc_take_value"; then
                if [[ "${#_argc_take_value}" -gt 1 ]]; then
                    break
                fi
            fi
            _argc_take_args_values+=("$_argc_take_value")
            _argc_take_args_len=$((_argc_take_args_len + 1))
            if [[ "$_argc_take_args_len" -ge "$max" ]]; then
                break
            fi
            _argc_take_index=$((_argc_take_index + 1))
        done
    fi
    if [[ "${#_argc_take_args_values[@]}" -lt "$min" ]]; then
        _argc_die "error: incorrect number of values for \`$param\`"
    fi
    if [[ -n "$delimiter" ]] && [[ "${#_argc_take_args_values[@]}" -gt 0 ]]; then
        local item values arr=()
        for item in "${_argc_take_args_values[@]}"; do
            IFS="$delimiter" read -r -a values <<<"$item"
            arr+=("${values[@]}")
        done
        _argc_take_args_values=("${arr[@]}")
    fi
}

_argc_match_positionals() {
    _argc_match_positionals_values=()
    _argc_match_positionals_len=0
    local params=("$@")
    local args_len="${#argc__positionals[@]}"
    if [[ $args_len -eq 0 ]]; then
        return
    fi
    local params_len=$# arg_index=0 param_index=0
    while [[ $param_index -lt $params_len && $arg_index -lt $args_len ]]; do
        local takes=0
        if [[ "${params[param_index]}" -eq 1 ]]; then
            if [[ $param_index -eq 0 ]] &&
                [[ ${_argc_dash:-} -gt 0 ]] &&
                [[ $params_len -eq 2 ]] &&
                [[ "${params[$((param_index + 1))]}" -eq 1 ]] \
                ; then
                takes=${_argc_dash:-}
            else
                local arg_diff=$((args_len - arg_index)) param_diff=$((params_len - param_index))
                if [[ $arg_diff -gt $param_diff ]]; then
                    takes=$((arg_diff - param_diff + 1))
                else
                    takes=1
                fi
            fi
        else
            takes=1
        fi
        _argc_match_positionals_values+=("$arg_index:$takes")
        arg_index=$((arg_index + takes))
        param_index=$((param_index + 1))
    done
    if [[ $arg_index -lt $args_len ]]; then
        _argc_match_positionals_values+=("$arg_index:$((args_len - arg_index))")
    fi
    _argc_match_positionals_len=${#_argc_match_positionals_values[@]}
    if [[ $params_len -gt 0 ]] && [[ $_argc_match_positionals_len -gt $params_len ]]; then
        local index="${_argc_match_positionals_values[params_len]%%:*}"
        _argc_die "error: unexpected argument \`${argc__positionals[index]}\` found"
    fi
}

_argc_maybe_flag_option() {
    local signs="$1" arg="$2"
    if [[ -z "$signs" ]]; then
        return 1
    fi
    local cond=false
    if [[ "$signs" == *"+"* ]]; then
        if [[ "$arg" =~ ^\+[^+].* ]]; then
            cond=true
        fi
    elif [[ "$arg" == -* ]]; then
        if (( ${#arg} < 3 )) || [[ ! "$arg" =~ ^---.* ]]; then
            cond=true
        fi
    fi
    if [[ "$cond" == "false" ]]; then
        return 1
    fi
    local value="${arg%%=*}"
    if [[ "$value" =~ [[:space:]] ]]; then
        return 1
    fi
    return 0
}

_argc_require_tools() {
    local tool missing_tools=()
    for tool in "$@"; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            missing_tools+=("$tool")
        fi
    done
    if [[ "${#missing_tools[@]}" -gt 0 ]]; then
        echo "error: missing tools: ${missing_tools[*]}" >&2
        exit 1
    fi
}

_argc_die() {
    if [[ $# -eq 0 ]]; then
        cat
    else
        echo "$*" >&2
    fi
    exit 1
}

_argc_run "$@"

# ARGC-BUILD }

if [ "$argc_quiet" = 1 ] || [ -z "$TERM" ] || [ "$TERM" = "dumb" ]; then
  bold=""
  reset=""
  blue=""
  green=""
  yellow=""
  cyan=""
  magenta=""
  red=""
else

  bold=$(tput bold)
  reset=$(tput sgr0)
  blue=$(tput setaf 4)
  green=$(tput setaf 2)
  yellow=$(tput setaf 3)
  cyan=$(tput setaf 6)
  magenta=$(tput setaf 5)
  red=$(tput setaf 1)
fi

if [ -z "$argc_term" ] && [ "$argc_contributors" != 1 ]; then
  "$0" -h
  exit 1
fi

if [ -f "$HOME/.config/github/token" ]; then
  GITHUB_TOKEN=$(cat "$HOME/.config/github/token")
  auth_header="Authorization: token $GITHUB_TOKEN"
elif [ -n "$GITHUB_TOKEN" ]; then
  auth_header="Authorization: token $GITHUB_TOKEN"
else
  echo "${yellow}Warning:${reset} No GitHub token found. API rate limits will be restricted." >&2
  echo "Create a token at https://github.com/settings/tokens and save it to ~/.config/github/token" >&2
  auth_header=""
fi

search_query="$argc_term"

if [ -n "$argc_email" ]; then
  search_query="$search_query author-email:$argc_email"
fi

if [ -n "$argc_author" ]; then
  search_query="$search_query author:$argc_author"
fi

if [ -n "$argc_org" ]; then
  search_query="$search_query org:$argc_org"
fi

if [ -n "$argc_user" ]; then
  search_query="$search_query user:$argc_user"
fi

if [ "$argc_fork" != 1 ]; then
  search_query="$search_query fork:false"
fi

encoded_query=$(echo "$search_query" | sed 's/ /%20/g')

[ -z "$argc_limit" ] && argc_limit="10"

[ -z "$argc_sort" ] && argc_sort="stars"
url="https://api.github.com/search/repositories?q=$encoded_query&sort=$argc_sort&per_page=$argc_limit"

if [ "$argc_json" != 1 ]; then
  printf "${bold}Searching GitHub:${reset} ${blue}%s${reset}" "$argc_term"
  [ -n "$argc_email" ] && printf " ${bold}by email:${reset} ${magenta}%s${reset}" "$argc_email"
  [ -n "$argc_author" ] && printf " ${bold}by author:${reset} ${magenta}%s${reset}" "$argc_author"
  [ -n "$argc_org" ] && printf " ${bold}in org:${reset} ${magenta}%s${reset}" "$argc_org"
  [ -n "$argc_user" ] && printf " ${bold}for user:${reset} ${magenta}%s${reset}" "$argc_user"

  limit_display="${argc_limit:-10}"
  sort_display="${argc_sort:-stars}"
  printf " (limit: ${yellow}%s${reset}, sorting by: ${cyan}%s${reset})\n" "$limit_display" "$sort_display"
  printf "%s\n" "----------------------------------------"
fi

analyze_repo() {
  local repo_name="$1"
  local repo_api_name="$2"

  printf "${bold}${cyan}Analyzing ${repo_name}...${reset}\n"

  # get repository details and emails
  printf "${bold}${yellow}Recent Contributors:${reset}\n"
  if [ -n "$auth_header" ]; then
    contributors=$(curl -s -H "$auth_header" "https://api.github.com/repos/${repo_api_name}/contributors?per_page=10")
  else
    contributors=$(curl -s "https://api.github.com/repos/${repo_api_name}/contributors?per_page=10")
  fi

  echo "$contributors" | jq -r '.[] | "\(.contributions) - \(.login)"' |
    awk '{printf "  %s - %s\n", $1, substr($0, length($1)+4)}'

  # commit patterns - this is a bit more complex but bassically
  # we want to find the most common commit patterns
  # this includes the date and hour of the commit
  # we'll use the commit author date to find patterns like 
  # "most commits on Mondays at 10:00"
  # this is useful for finding active times of the repository
  # and can help identify when contributors are most active
  # we'll also check for email addresses in the commit data
  # and print a sample of the emails found
  printf "\n${bold}${yellow}Commit Patterns:${reset}\n"
  if [ -n "$auth_header" ]; then
    commits=$(curl -s -H "$auth_header" "https://api.github.com/repos/${repo_api_name}/commits?per_page=100")
  else
    commits=$(curl -s "https://api.github.com/repos/${repo_api_name}/commits?per_page=100")
  fi

  echo "$commits" | jq -r '.[].commit.author.date' |
    awk -F'T' '{print $1, substr($2,1,2)}' | sort | uniq -c |
    sort -k2,2 -k3,3 | tail -10 |
    awk '{printf "  %s commits on %s at %s:00 hour\n", $1, $2, $3}'

  # check for email addresses
  email_count=$(echo "$commits" | jq '[.[] | select(.commit.author.email != null and .commit.author.email != "")] | length')
  printf "\n${bold}${yellow}Email Check:${reset} Found ${cyan}%s${reset} commits with email addresses\n" "$email_count"

  if [ "$email_count" -gt 0 ]; then
    printf "${bold}${yellow}Sample Emails:${reset}\n"
    echo "$commits" | jq -r '.[] | select(.commit.author.email != null and .commit.author.email != "") | "\(.commit.author.name) <\(.commit.author.email)>"' |
      sort -u | head -3 | sed 's/^/  /'
  else
    printf "${yellow}No emails found in commit data. This is likely due to GitHub API privacy restrictions.${reset}\n"
  fi

  # commit authors and emails
  printf "\n${bold}${yellow}Commit Authors:${reset}\n"
  echo "$commits" | jq -r '.[] | "\(.commit.author.name) <\(.commit.author.email)>"' | sort -u | head -5 |
    sed 's/^/  /'

  # get repository contents
  printf "\n${bold}${yellow}Interesting Files:${reset}\n"
  if [ -n "$auth_header" ]; then
    contents=$(curl -s -H "$auth_header" "https://api.github.com/repos/${repo_api_name}/git/trees/HEAD?recursive=1")
  else
    contents=$(curl -s "https://api.github.com/repos/${repo_api_name}/git/trees/HEAD?recursive=1")
  fi

  echo "$contents" | jq -r '.tree[] | select(.type=="blob") | .path' |
    grep -E '\.conf$|\.env|\.key$|config\.|\.yml$|\.yaml$|\.json$|\.xml$|\.pem$|\.crt$|\.cer$' |
    grep -v "node_modules\|vendor" | head -10 |
    sed 's/^/  /'
}

enumerate_contributors() {
  local target="$1"
  local target_type="$2" # 'user' or 'org'
  local page=1
  local repos=()
  local all_repos_json=""

  printf "${bold}${cyan}Enumerating repositories for ${target_type} '${target}'...${reset}\n"

  # fetch all repositories for the user/org
  while true; do
    local url="https://api.github.com/${target_type}s/${target}/repos?per_page=100&page=${page}"
    if [ "$argc_fork" != 1 ]; then
      if [ "$target_type" = "org" ]; then
        url="${url}&type=sources" # use 'sources' for orgs to exclude forks reliably
      else                        # user
        :                         # skip user
      fi
    fi

    local repos_json
    if [ -n "$auth_header" ]; then repos_json=$(curl -s -L -H "$auth_header" "$url"); else repos_json=$(curl -s -L "$url"); fi # Added -L for redirects

    if ! echo "$repos_json" | jq -e . >/dev/null 2>&1; then
      printf "${red}Error:${reset} Invalid JSON received from GitHub API for repos page ${page}. URL: ${url}\n" >&2
      printf "Response was: %s\n" "$repos_json" >&2
      return 1
    fi
    if echo "$repos_json" | jq -e '.message' >/dev/null 2>&1; then
      printf "${red}Error:${reset} GitHub API returned: %s\n" "$(echo "$repos_json" | jq -r '.message')"
      if [ ${#repos[@]} -eq 0 ]; then return 1; else break; fi
    fi
    if [ "$(echo "$repos_json" | jq '. | length')" -eq 0 ]; then break; fi

    while read -r repo fork_status; do
      if [ "$argc_fork" != 1 ] && [ "$fork_status" = "true" ]; then
        printf "  ${yellow}Skipping fork:${reset} ${blue}%s${reset}\n" "$repo"
        continue
      fi
      repos+=("$repo")
    done < <(echo "$repos_json" | jq -r '.[] | "\(.full_name) \(.fork)"')

    ((page++))
    # sleep 0.2 # be nice to the api
  done

  total_repos=${#repos[@]}
  fork_status=""
  if [ "$argc_fork" = 1 ]; then fork_status=" (including forks)"; else fork_status=" (excluding forks)"; fi
  printf "${bold}Found ${yellow}%s${reset} repositories${reset}${cyan}%s${reset}\n\n" "$total_repos" "$fork_status"

  if [ "$total_repos" -eq 0 ]; then
    printf "${yellow}No repositories found matching criteria.${reset}\n"
    return 0
  fi

  temp_file=$(mktemp)
  trap 'rm -f "$temp_file"' EXIT TERM INT

  total_direct_commits_all_repos=0
  total_merge_commits_all_repos=0

  repo_count=0
  for repo in "${repos[@]}"; do
    ((repo_count++))
    printf "${bold}Processing repo ${yellow}%d/%d${reset}: ${green}%s${reset}...${reset}\n" "$repo_count" "$total_repos" "$repo"

    local commits_page=1
    local direct_commit_count_repo=0
    local merge_commit_count_repo=0

    while true; do
      local commits_url="https://api.github.com/repos/${repo}/commits?per_page=100&page=${commits_page}"
      local commits_json
      if [ -n "$auth_header" ]; then commits_json=$(curl -s -L -H "$auth_header" "$commits_url"); else commits_json=$(curl -s -L "$commits_url"); fi # Added -L

      if ! echo "$commits_json" | jq -e . >/dev/null 2>&1; then
        printf "  ${red}Error:${reset} Invalid JSON received from GitHub API for commits page ${commits_page}. URL: ${commits_url}\n" >&2
        printf "  Response was: %s\n" "$commits_json" >&2

        # actually unsure whether to break or continue lol
        break
      fi
      if echo "$commits_json" | jq -e '.message' >/dev/null 2>&1; then
        error_msg=$(echo "$commits_json" | jq -r '.message')
        if [[ "$error_msg" == "Git Repository is empty." ]]; then
          printf "  ${yellow}Skipping empty repository.${reset}\n"
        elif [[ "$error_msg" == "Not Found" ]]; then
          printf "  ${red}Error:${reset} Repository not found or insufficient permissions: ${red}%s${reset}\n" "$repo"
        elif [[ "$error_msg" == *"API rate limit exceeded"* ]]; then
          printf "  ${red}Error:${reset} API rate limit exceeded. Try again later or use a token.\n"
          # getting rate limit sneed :(
        else
          printf "  ${yellow}Warning:${reset} Could not fetch commits: ${yellow}%s${reset}\n" "$error_msg"
        fi
        break
      fi
      if [ "$(echo "$commits_json" | jq '. | length')" -eq 0 ]; then break; fi

      direct_count=$(echo "$commits_json" | jq '[.[] | select(.parents | length <= 1)] | length')
      merge_count=$(echo "$commits_json" | jq '[.[] | select(.parents | length > 1)] | length')
      direct_commit_count_repo=$((direct_commit_count_repo + direct_count))
      merge_commit_count_repo=$((merge_commit_count_repo + merge_count))

      echo "$commits_json" | jq -c -r --arg repo "$repo" ' 
          .[] |
          select(.parents | length <= 1) | 
          select(.commit.author.email != null and .commit.author.email != "" and (.commit.author.email | contains("@") ) ) | 
          select(.commit.author.date != null) | # Ensure date exists
          {
              repo: $repo,
              name: .commit.author.name,
              email: .commit.author.email,
              date: .commit.author.date,
              login: (if .author and .author.login then .author.login else null end) # Get login if available
          }
          ' >>"$temp_file"

      ((commits_page++))
      sleep 0.1
    done

    total_repo_commits=$((direct_commit_count_repo + merge_commit_count_repo))
    total_direct_commits_all_repos=$((total_direct_commits_all_repos + direct_commit_count_repo))
    total_merge_commits_all_repos=$((total_merge_commits_all_repos + merge_commit_count_repo))
    printf "  ${cyan}Processed${reset} ${yellow}%s${reset} total commits (${cyan}%s${reset} direct, ${magenta}%s${reset} merge)\n" "$total_repo_commits" "$direct_commit_count_repo" "$merge_commit_count_repo"
    sleep 0.1 # Sleep between repos
  done

  printf "\n${bold}${cyan}Direct Commit Author Summary:${reset}\n"
  printf "${bold}%-40s %-30s %-50s${reset}\n" "Email" "Name" "Repositories (Direct Commits)"
  printf "%-40s %-30s %-50s\n" "$(printf -- '%.0s-' {1..40})" "$(printf -- '%.0s-' {1..30})" "$(printf -- '%.0s-' {1..50})"

  if [ ! -s "$temp_file" ]; then
    printf "${yellow}No direct commit authors with email addresses found across scanned repositories.${reset}\n"
  else
    jq -s ' 
      group_by(.email) |
      map({
          email: .[0].email,
          name: .[0].name,
          repos: map(.repo) | unique | sort, 
          logins: map(.login) | unique | map(select(. != null)) | sort,
          direct_commit_count: length, # Count of direct commits across all repos
          last_direct_commit_date: map(.date) | sort | reverse[0] # Date of last direct commit
      }) | sort_by(.name) 
      ' "$temp_file" | jq -r '.[] |
          .email as $email |
          .name as $name |
          # Join repos into a comma-separated string for display
          (.repos | join(", ")) as $repos_str |
          $email + "|" + $name + "|" + $repos_str
      ' |
      while IFS="|" read -r email name repos_str; do

        email_trunc=$(echo "$email" | awk '{ if(length($0) > 38) { print substr($0, 1, 37) "…" } else { print $0 } }')
        name_trunc=$(echo "$name" | awk '{ if(length($0) > 28) { print substr($0, 1, 27) "…" } else { print $0 } }')
        repos_trunc=$(echo "$repos_str" | awk '{ if(length($0) > 48) { print substr($0, 1, 45) "..." } else { print $0 } }')

        printf "${magenta}%-40s${reset} ${green}%-30s${reset} ${blue}%-50s${reset}\n" \
          "$email_trunc" "$name_trunc" "$repos_trunc"
      done

    printf "\n${bold}${yellow}Recent Direct Commit Timestamps (Most Recent 50):${reset}\n"
    jq -r '.date + "|" + .name + "|" + .email + "|" + .repo' "$temp_file" |
      sort -r |
      head -n 50 |
      while IFS="|" read -r timestamp name email repo; do
        date_part=$(echo "$timestamp" | cut -dT -f1)
        time_part=$(echo "$timestamp" | cut -dT -f2 | cut -d. -f1)
        tz_part=$(echo "$timestamp" | grep -o '[+-][0-9]\{2\}:[0-9]\{2\}$' || echo "Z")

        repo_short=$(echo "$repo" | sed 's|.*/||')

        printf "  ${cyan}%s${reset} ${magenta}%s${reset} ${yellow}%s${reset} by ${green}%s${reset} <${blue}%s${reset}> in ${yellow}%s${reset}\n" \
          "$date_part" "$time_part" "$tz_part" \
          "$(echo "$name" | cut -c 1-20)" \
          "$(echo "$email" | cut -c 1-25)" \
          "$repo_short"
      done

    output_file="direct-commit-authors-${target_type}-${target}-$(date +%Y%m%d-%H%M%S).json"
    jq -s '
      group_by(.email) |
      map({
          email: .[0].email,
          name: .[0].name,
          repos: map(.repo) | unique | sort,
          logins: map(.login) | unique | map(select(. != null)) | sort,
          direct_commit_count: length,
          last_direct_commit_date: map(.date) | sort | reverse[0]
      }) | sort_by(-.direct_commit_count) 
      ' "$temp_file" >"$output_file"

    printf "\n${bold}${yellow}Top Direct Commit Authors (by commit count):${reset}\n"
    jq -r '.[0:10] | .[] | "\(.direct_commit_count) direct commits - \(.name) <\(.email)>"' "$output_file" 2>/dev/null |
      sed 's/^/  /'

    printf "\n${bold}${yellow}All Direct Commit Authors (Name and Email):${reset}\n"
    jq -r 'sort_by(.name) | .[] | "\(.name) <\(.email)>"' "$output_file" | sort -u |
      sed 's/^/  /'

    printf "\n${bold}${yellow}Recent Direct Commit Authors:${reset}\n"
    jq -r 'sort_by(.last_direct_commit_date) | reverse | .[0:10] | .[] | "\(.name) <\(.email)> (last direct commit: \(.last_direct_commit_date | split("T")[0]))"' "$output_file" 2>/dev/null |
      sed 's/^/  /'

    printf "\n${bold}${yellow}Data saved to:${reset} ${cyan}%s${reset}\n" "$output_file"

  fi

  printf "\n${bold}${yellow}Summary:${reset}\n"
  printf "%s Total repositories scanned: ${cyan}%s${reset}\n" "-" "$total_repos"
  printf "%s Total direct commits found: ${cyan}%s${reset}\n" "-" "$total_direct_commits_all_repos"
  printf "%s Total merge commits found: ${cyan}%s${reset}\n" "-" "$total_merge_commits_all_repos"

  if [ -s "$temp_file" ]; then
    unique_authors=$(jq -s 'group_by(.email) | length' "$temp_file" 2>/dev/null || echo "N/A")
    printf "%s Unique direct commit authors found (with email): ${cyan}%s${reset}\n" "-" "$unique_authors"

    unique_emails=$(jq -s '[.[] | .email] | unique | length' "$temp_file" 2>/dev/null || echo "N/A")
    printf "%s Unique email addresses found in direct commits: ${cyan}%s${reset}\n" "-" "$unique_emails"

    if [ "$unique_emails" != "0" ] && [ "$unique_emails" != "N/A" ]; then
      email_domains=$(jq -r '.email | select(type=="string" and contains("@")) | split("@")[1]' "$temp_file" 2>/dev/null | sort -u)
      if [ -n "$email_domains" ]; then
        printf "%s Email domains: ${cyan}%s${reset}\n" "-" "$(echo "$email_domains" | tr '\n' ', ' | sed 's/,$//' | sed 's/,/, /g')"
      else
        printf "%s ${yellow}No valid email domains found in direct commits${reset}\n" "-"
      fi
    else
      printf "%s ${yellow}No email domains found${reset}\n" "-"
      printf "  ${yellow}Note: Some commits might lack email info or privacy settings hide it.${reset}\n"
    fi
  else
    printf "%s Unique direct commit authors found (with email): ${cyan}0${reset}\n" "-"
    printf "%s Unique email addresses found in direct commits: ${cyan}0${reset}\n" "-"
    printf "%s ${yellow}No email domains found${reset}\n" "-"
  fi

  rm -f "$temp_file"
  trap - EXIT TERM INT

}

if [ "$argc_contributors" = "true" ] || [ "$argc_contributors" = "1" ]; then
  printf "${bold}${cyan}Starting contributor enumeration...${reset}\n"

  if [ -n "$argc_org" ]; then
    enumerate_contributors "$argc_org" "org"
    exit $?
  elif [ -n "$argc_user" ]; then
    enumerate_contributors "$argc_user" "user"
    exit $?
  else
    printf "${red}Error:${reset} --contributors flag requires either --org or --user to be specified\n"
    printf "\n${bold}Usage examples:${reset}\n"
    printf "  ${cyan}$(basename "$0") --contributors --org spearbit${reset}    # Enumerate contributors in the 'spearbit' organization\n"
    printf "  ${cyan}$(basename "$0") --contributors --user vbuterin${reset}   # Enumerate contributors in repositories owned by 'vbuterin'\n"
    printf "\nFor full help, run: ${cyan}$(basename "$0") --help${reset}\n"
    exit 1
  fi
fi

if [ -n "$auth_header" ]; then
  response=$(curl -s -H "$auth_header" "$url")
else
  response=$(curl -s "$url")
fi

if echo "$response" | jq -e '.message' >/dev/null 2>&1; then
  error_msg=$(echo "$response" | jq -r '.message')
  printf "${red}Error:${reset} GitHub API returned: ${red}%s${reset}\n" "$error_msg"
  exit 1
fi

if [ "$argc_json" = 1 ]; then
  echo "$response" | jq
else
  total_count=$(echo "$response" | jq -r '.total_count')
  printf "${bold}Found ${yellow}%s${reset} matching repositories${reset}\n\n" "$total_count"

  echo "$response" | jq -r '.items[] | "\(.full_name)|\(.stargazers_count)|\(.forks_count)|\(.description)|\(.language)|\(.html_url)|\(.clone_url)|\(.updated_at)"' |
    while IFS="|" read -r repo stars forks desc lang url clone_url updated_at; do
      formatted_date=$(date -d "$updated_at" "+%Y-%m-%d %H:%M" 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$updated_at" "+%Y-%m-%d %H:%M" 2>/dev/null)

      printf "${bold}* ${green}%s${reset} (${yellow}%s*${reset} | ${cyan}%s^${reset})" "$repo" "$stars" "$forks"
      [ -n "$lang" ] && printf " ${magenta}[%s]${reset}" "$lang"
      printf " ${yellow}Updated: %s${reset}\n" "$formatted_date"
      [ -n "$desc" ] && printf "  ${cyan}%s${reset}\n" "$desc"
      printf "  ${blue}%s${reset}\n" "$url"

      if [ "$argc_deep" = 1 ]; then
        analyze_repo "$repo" "$repo"
      fi

      printf "\n"
    done
fi

if [ -n "$auth_header" ]; then
  rate_limit=$(curl -s -H "$auth_header" https://api.github.com/rate_limit)
  remaining=$(echo "$rate_limit" | jq -r '.rate.remaining')
  reset_time=$(echo "$rate_limit" | jq -r '.rate.reset')
  reset_date=$(date -d "@$reset_time" "+%H:%M:%S" 2>/dev/null || date -r "$reset_time" "+%H:%M:%S" 2>/dev/null)

  printf "${bold}${yellow}API Rate Limit:${reset} ${remaining} requests remaining, resets at ${reset_date}\n"
fi
